import customtkinter as ctk
from tkinter import messagebox #confirmation 
import re # for valid email pattern
import sqlite3 #db
import hashlib #hashes

ctk.set_appearance_mode("light")
ctk.set_default_color_theme("green")



class NEA(ctk.CTk):
    def openpage(self,current,page): 
        current.place_forget() 
        page.place(relwidth=1, relheight=1)
    def quiztaken(self,user_id,currentpage): # checks if user has taken quiz
        self.current_user_id = user_id  # stores current user id
        self.cursor.execute("SELECT quiz_taken FROM users WHERE id = ?",(user_id,)) #Checks database for it quiz has been taken
        result = self.cursor.fetchone() # fetches result
        print(result)
        if result and result[0] == 0: # if quiz not taken
            self.openpage(currentpage, self.quizpage)
        else: # if quiz taken
            self.openpage(currentpage, self.mainpage)
    def save_quiz_answers(self,quiz_answers):
        for question_num, answer in quiz_answers.items():
            if isinstance(answer, list):
                answer = ', '.join(answer)
            self.cursor.execute("INSERT INTO quiz_answers (user_id, question_num, answer) VALUES (?, ?, ?)", (self.current_user_id, question_num, answer))
        self.db.commit()
    def create_header(self, parent):
        header = ctk.CTkFrame(parent, fg_color="#25995e", height=0.2)
        header.place(relx=0, rely=0, relwidth=1, relheight=0.12)
        logintext = ctk.CTkLabel(header, text="UniPicker", font=("Tahoma", 55, "bold"), 
                                 text_color="white", fg_color="#25995e")
        logintext.place(anchor="w", rely=0.5, relx=0.04)
        

        
        signout = ctk.CTkLabel(header, text="Sign Out", font=("Tahoma", 25, "bold"), text_color="white", 
                               fg_color="#25995e", cursor="hand2")
        signout.place(anchor="e", rely=0.5, relx=0.96)
        signout.bind("<Button-1>", lambda event: self.openpage(parent, self.loginpage))
    def __init__(self):
        super().__init__()
        self.state('zoomed')          # standards across all pages
        self.geometry('1920x1080') 
        self.title("UniPicker")
        self.configure(fg_color="white")
        self.saved_universities = []
        #connect to db
        self.db = sqlite3.connect("login.db")
        self.cursor = self.db.cursor()

        self.db.commit()
        self.universitylist = [
            "University of Oxford", "University of Cambridge", "Imperial College London",
            "London School of Economics and Political Science", "University College London (UCL)", "University of Edinburgh",
            "University of Manchester", "Kings College London", "University of Bristol", "University of Glasgow",
        ]

 

        self.after(100, lambda: self.lift())              #opens python file to front in macos
        self.after(100, lambda: self.focus_force())   #macos
        self.after(100, lambda: self.attributes('-topmost', True))  #macos
        self.after(500, lambda: self.attributes('-topmost', False)) #macos
        self.current_user_id = None  # stores current user id

        
        self.mainpage = mainpage(parent=self,controller=self)
        self.quizpage = quizpage(parent=self,controller=self)
        self.loginpage = loginpage(self.db,self.cursor,parent=self,controller=self)
        self.signuppage = signuppage(self.db,self.cursor,parent=self,controller=self)
        self.mainpage.place(relwidth=1,relheight=1)
class loginpage(ctk.CTkFrame):
    def __init__(self,db,cursor,parent,controller):
        super().__init__(parent)
        self.configure(fg_color="#e8f5e9")
        self.controller = controller
        self.db = db
        self.cursor = cursor

        self.unipicker = ctk.CTkLabel(self,text="UniPicker",text_color="#25995e",font=("Tahoma",80,"bold"))
        self.unipicker.pack(anchor="center",pady="100")
        self.form_frame = ctk.CTkFrame(self,border_color="#e2e8f0",fg_color="white",corner_radius=15,border_width=1) # Frame of the form
        self.form_frame.place(relx=0.5,rely=0.53,anchor="center")
        #log in
        self.logintext_frame = ctk.CTkFrame(self.form_frame,fg_color="white")
        self.logintext_frame.pack(pady=40,padx=20,anchor="w")

        self.logintext = ctk.CTkLabel(self.logintext_frame,text="Welcome Back", font=("Inter",35,'bold'),text_color="black",fg_color="white")
        self.logintext.pack(anchor="w",pady=5)
        self.logintext1 = ctk.CTkLabel(self.logintext_frame,text="Sign in to continue.", font=("Inter",18),text_color="gray",fg_color="white")
        self.logintext1.pack(anchor="w")
        #email box

        self.email_form = ctk.CTkEntry(self.form_frame, font= ("Tahoma",20,"normal"), placeholder_text="Email Address",width=550,
                                       height=60,border_width=2,fg_color='#e8f5e9',border_color="#c8e6c9",corner_radius=12 ) 
        self.email_form.pack(padx=15,pady=10)
                #password box


        self.password_form_frame = ctk.CTkFrame(self.form_frame,fg_color="white")
        self.password_form_frame.pack(anchor="w",pady=20,padx=10,fill="x")


        self.password_form = ctk.CTkEntry(self.password_form_frame, font= ("Tahoma",20,"normal"), placeholder_text="Password",show="*",
                                          text_color='black',fg_color='#e8f5e9',width=550,height=60,
                                          border_width=2,border_color="#c8e6c9",corner_radius=12)
        self.password_form.pack(padx=15, pady=0)
        self.forgotpassword = ctk.CTkLabel(self.password_form_frame,text="Forgot Password?",
                                           text_color="#25995e",fg_color="white",font=("Inter",15,"bold"),cursor="hand2")
        self.forgotpassword.pack(anchor="e",side="right",padx=20,pady=10)








        self.loginbtn = ctk.CTkButton(self.form_frame, text="Login",font=("Inter",20,"bold"),text_color="white",cursor="hand2",fg_color="#25995e",
                                      width=500,height=60,corner_radius=12,command=self.accountchecker)
        self.loginbtn.pack(pady=15,padx=0)
        self.signupcheckform = ctk.CTkFrame(self.form_frame, fg_color="white")
        self.signupcheckform.pack(anchor="center",pady=20, padx=10)

        self.signupcheck = ctk.CTkLabel(self.signupcheckform, text="New to Unipicker?", text_color="gray", 
                                        fg_color="white", font=("Tahoma",16))
        self.signupcheck1 = ctk.CTkLabel(self.signupcheckform, text="Create an account", text_color="#25995e",
                                          fg_color="white", font=("Inter",15,'bold'), cursor="hand2")
        self.signupcheck1.bind("<Button-1>",lambda event: self.controller.openpage(self,self.controller.signuppage))
        self.signupcheck.pack(side="left", padx=3, anchor="center")
        self.signupcheck1.pack(side="left", padx=3, anchor="center")
        
    def accountchecker(self):
        emailcheck = self.email_form.get()
        passcheck = self.password_form.get()
        self.cursor.execute("SELECT Password FROM users WHERE Email = ?", (emailcheck, )) # finds email
        result = self.cursor.fetchone() # stores results
        if passcheck == "" or emailcheck == "": # checks fields arent empty
            messagebox.showinfo("Error", "Email/Password cannot be blank")
            return
        if result: # if a result is found
            stored_password = result[0]
            hashed_password = hashlib.sha256(passcheck.encode()).hexdigest()
            if hashed_password == stored_password:
                print("Success")
                self.cursor.execute("SELECT id FROM users WHERE Email = ?", (emailcheck, )) # finds email
                result1 = self.cursor.fetchone() # stores results
                messagebox.showinfo("Login", "Login successful")
                self.controller.quiztaken(result1[0],self) 
                print(result1[0]) # prints user id
            else:
                print("fail")
                messagebox.showinfo("Error", "Incorrect email or password")
        if not result: # if no result is found
            messagebox.showinfo("Error", "Incorrect email or password")
    
    
class signuppage(ctk.CTkFrame):
    def __init__(self,db,cursor,parent,controller):
        super().__init__(parent)
        self.controller = controller
        self.configure(fg_color="#e8f5e9")
        self.unipicker = ctk.CTkLabel(self,text="UniPicker",text_color="#25995e",font=("Tahoma",80,"bold")) #Title
        self.unipicker.pack(anchor="center",pady="100")
        self.db = db 
        self.cursor = cursor
                        
                        
        self.form_frame = ctk.CTkFrame(self,border_color="#2b2b2b",fg_color="white",corner_radius=12) # Frame of the form
        self.form_frame.place(relx=0.5,rely=0.53,anchor="center")

        self.entryform_frame = ctk.CTkFrame(self.form_frame,fg_color="white") # Frame of the entry fields
        self.entryform_frame.pack(pady=20,padx=10)
        self.signuptext_frame = ctk.CTkFrame(self.entryform_frame,fg_color="white") #signuptext is in entry form so padding of entryform doesnt affect signuptext
        self.signuptext_frame.pack(pady=30,padx=10,anchor="w")

        self.signuptext = ctk.CTkLabel(self.signuptext_frame,text="Create an account", font=("Inter",35,"bold"),text_color="black",fg_color="white")
        self.signuptext.pack(anchor="w")
        self.signuptext1 = ctk.CTkLabel(self.signuptext_frame,text="Sign Up to continue.", font=("Inter",18),text_color="gray",fg_color="white")
        self.signuptext1.pack(anchor="w")


        self.name_form = ctk.CTkEntry(self.entryform_frame, font= ("Tahoma",20,"normal"),placeholder_text="Name" ,
        width=550,height=60,border_width=2,fg_color='#e8f5e9',border_color="#c8e6c9",corner_radius=12) 
        self.name_form.pack(padx=15,pady=10)


        self.email_form = ctk.CTkEntry(self.entryform_frame, font= ("Tahoma",20,"normal"),placeholder_text="Email Address" ,
        width=550,height=60,border_width=2,fg_color='#e8f5e9',border_color="#c8e6c9",corner_radius=12) 
        self.email_form.pack(padx=15,pady=10)



        self.password_form_frame = ctk.CTkFrame(self.entryform_frame,fg_color="white") # Holds the password form
        self.password_form_frame.pack(anchor="w",pady=0,padx=10,fill="x")

        self.password_form = ctk.CTkEntry(self.password_form_frame, font= ("Tahoma",20,"normal"), 
        placeholder_text="Password",show="*",text_color='black',fg_color='#e8f5e9',width=550,height=60,border_width=2,border_color="#c8e6c9",corner_radius=12)
        self.password_form.pack(padx=10,pady=15)


        self.loginbtn = ctk.CTkButton(self.form_frame, text="Create account",font=("Inter",20,"bold"),text_color="white",
        cursor="hand2",fg_color="#25995e",width=500,height=60,corner_radius=12,command=self.signup_user)
        self.loginbtn.pack(pady=10,padx=0)
        self.signupcheckform = ctk.CTkFrame(self.form_frame, fg_color="white")
        self.signupcheckform.pack(anchor="center",pady=18, padx=10)

        self.signupcheck = ctk.CTkLabel(self.signupcheckform, text="Already have an account?", text_color="gray", fg_color="white", font=("Tahoma",16))
        self.signupcheckbutton = ctk.CTkLabel(self.signupcheckform, text="Sign in", text_color="#25995e", fg_color="white", font=("Inter",16,'bold'), cursor="hand2")
        self.signupcheckbutton.bind("<Button-1>",lambda event: self.controller.openpage(self,self.controller.loginpage))
        self.signupcheck.pack(side="left", padx=2, anchor="center")
        self.signupcheckbutton.pack(side="left", padx=5, anchor="center")

    # Validation functions
    def validname(self,name): 
        if len(name) < 2 or len(name) > 15: # checks name length
            messagebox.showinfo("Error", "Name must be between 2 and 15 characters long")
            return False
        if not name.isalpha(): # can only contain letter and spaces
            messagebox.showinfo("Error", "Name must contain only letters and spaces!")
            return False
        else:
            return True
    def validemail(self, email):
        pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'  # checks if valid email follows email format
        return re.match(pattern, email) is not None # returns true if email is valid
    def validpass(self,password):
        if len(password) < 10:
            messagebox.showinfo("Error", "Password must be above 10 characters!")
            return False
        if not re.search(r'[A-Z]', password):
            messagebox.showinfo("Error", "Password must contain at least one uppercase letter!") # checks for uppercase
            return False
        if not re.search(r'[a-z]', password):
            messagebox.showinfo("Error", "Password must contain at least one lowercase letter!") # checks for lowercase
            return False
        if not re.search(r'\d', password):
            messagebox.showinfo("Error", "Password must contain at least one digit!") # checks for digit
            return False
        else:
            return True
        
        
        
        
    
    def passwordhasher(self,password):
        return hashlib.sha256(password.encode()).hexdigest()
    def signup_user(self):
        newname = self.name_form.get()
        newuser = self.email_form.get()
        newpass = self.password_form.get()
        if not newuser or not newpass or not newname: # checks fields arent empty
            messagebox.showinfo("Error", "Name/Username/Password cannot be blank")
            return
        if not self.validname(newname):
            return
        if not self.validemail(newuser):
            messagebox.showinfo("Error", "Invalid email format")
        else: 
            self.cursor.execute("SELECT Email FROM users WHERE Email = ?", (newuser, )) # finds email
            result = self.cursor.fetchone() # stores results
            if result: # if a result is found
                messagebox.showinfo("Error", "Email already exists")
                return
            if self.validpass(newpass) is False: # checks if password is valid via validpass function
                print("Password not valid!")
            else:
                self.hashedpass = self.passwordhasher(newpass)
                self.cursor.execute("INSERT INTO users (Name,Email,Password) VALUES (?, ?, ?)", (newname,newuser, self.hashedpass)) # inserts new user
                self.db.commit()
                messagebox.showinfo("Success!","user registered success!")
                self.cursor.execute("SELECT id FROM users WHERE email = ?", (newuser,))
                result1 = self.cursor.fetchone() # fetch user id

                if result1:
                    user_id = result1[0] # get user id
                    self.controller.quiztaken(user_id, self)

                    
class quizpage(ctk.CTkFrame):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.configure(fg_color="white")
        self.controller = controller
        self.controller.create_header(self) ####
        # Body
        self.scrollableframe = ctk.CTkScrollableFrame(self, fg_color="white")
        self.scrollableframe.place(relx=0, rely=0.12, relwidth=1, relheight=0.88)

        self.quiz_answers = {}
        self.current_question_index = 0
        self.questions = [
            {
                "text": "Are you interested in any potential universities?",
                "type": "multi",
                "questionnumber": 1,
                "options": self.controller.universitylist,
                "handler": self.multi_selected
            },
            {
                "text": "Do you plan on staying at home or moving away for university?",
                "type": "single",
                "questionnumber": 2,
                "options": ["Staying at home", "Moving away", "Not sure"],
                "handler": self.single_selected
            },
            {
                "text": "What is your postcode? (For location-based recommendations)",
                "type": "text",
                "questionnumber": 3,
                "handler": self.postcode_selected,
            },
            {
                "text": "Do you require financial information?",
                "type": "single",
                "questionnumber": 4,
                "options": ["Yes", "No"],
                "handler": self.single_selected
            },
            {
                "text": "Do you prefer a city or campus university?",
                "type": "single",
                "questionnumber": 5,
                "options": ["City", "Campus", "No preference"],
                "handler": self.single_selected
            },
            {
                "text": "Are you interested in studying in London?",
                "type": "single",
                "questionnumber": 6,
                "options": ["Yes", "No", "No preference"],
                "handler": self.single_selected
            },
            {
                "text": "Which extracurricular activities are you interested in?",
                "type": "multi",
                "questionnumber": 7,
                "options": ["Sports","Art/music","Societies","Job opportunities (part-time)","Job opportunities (internships)"],
                "handler": self.multi_selected
            },
            {
                "text": "How important is nightlife to you?",
                "type": "single",
                "questionnumber": 8,
                "options": ["Very important", "Somewhat important", "Not important"],
                "handler": self.single_selected
            }
        ]
        # Hide all widgets first
        #self.answer_menu.pack_forget()
        #self.single_choice_frame.pack_forget()
        #self.continue_button.pack_forget()
        #self.postcode_entry.pack_forget()
        self.question_label = ctk.CTkLabel(self.scrollableframe, font=("Tahoma", 35, "bold"), text_color="#25995e") # Question label
        self.question_label.pack(pady=(50, 30))
        self.answer_menu = ctk.CTkOptionMenu(self.scrollableframe, height=80, width=500, font=("Tahoma", 20), values=[])# Dropdown menu
        self.single_choice_frame = ctk.CTkFrame(self.scrollableframe, fg_color="white") # Frame for single choice buttons
        self.postcode_entry = ctk.CTkEntry(self.scrollableframe, font=("Tahoma", 20), placeholder_text="Enter your postcode", width=500, height=70, border_width=0, fg_color='lightgrey', corner_radius=10)
        self.continue_button = ctk.CTkButton(self.scrollableframe, text="Continue", font=("Tahoma", 30, "bold"), command=self.next_question, width=400, height=70)
        self.selected_answers = {}
        self.display_question() # Display the first question

    def display_question(self):
        question = self.questions[self.current_question_index] # gets current question
        # Hide/destroy all widgets first
        self.answer_menu.pack_forget()
        self.single_choice_frame.pack_forget()
        self.continue_button.pack_forget()
        self.postcode_entry.pack_forget()
        for widget in self.single_choice_frame.winfo_children():
            widget.destroy()


        self.question_label.configure(text=question["text"]) # displays the quiz question

        #for each question type, display the widgets
    
        if question["type"] == "multi": # if a multiple choice question
            for option in question["options"]: # for each option
                var = ctk.IntVar() # checks if box has been ticked
                check = ctk.CTkCheckBox(self.single_choice_frame, text=option, font=("Tahoma", 20), variable=var, command=lambda choice=option, v=var: self.multi_selected(choice, v)) # tick box
                check.pack(side="top", anchor="w", pady=10)
            self.single_choice_frame.pack(pady=(30, 20), anchor="center")
            self.continue_button.pack(pady=(20, 10)) # places continue button

        elif question["type"] == "single": # if a single choice question
            for option in question["options"]:
                btn = ctk.CTkButton(self.single_choice_frame, text=option, font=("Tahoma", 20), command=lambda choice=option: question["handler"](choice), width=250, height=60)
                btn.pack(side="left", padx=30, pady=20)
            self.single_choice_frame.pack(pady=(30, 20), anchor="center")

        elif question["type"] == "text": # if a text question
            self.postcode_entry.pack(pady=(100, 20), anchor="center") # place entry box
            self.postcode_entry.bind("<Return>", lambda event: question["handler"]()) # if user clicks enter key, moves to next question
            self.continue_button.configure(text="Submit", command=question["handler"]) # changes continue button to submit and calls handler function
            self.continue_button.pack(pady=(200, 10))

    def next_question(self):
        current_q = self.questions[self.current_question_index]["questionnumber"] # holds current q number
        current_selection = self.selected_answers.get(self.current_question_index)  # gets current selection
        self.quiz_answers[current_q] = current_selection
        if self.current_question_index < len(self.questions) - 1: # if more questions
            self.current_question_index += 1
            self.display_question()
        else:
            messagebox.showinfo("Quiz Completed", "Please continue to the main page.") # no more questions
            self.controller.save_quiz_answers(self.quiz_answers) # saves quiz answers to db
            print(self.quiz_answers)
            self.controller.cursor.execute("UPDATE users SET quiz_taken = 1 WHERE id = ?", (self.controller.current_user_id,)); self.controller.db.commit()
            
            self.controller.openpage(self, self.controller.mainpage)

    # Handlers for different question types
    def multi_selected(self, choice,var):
        if var.get() == 1: # if selected
            if self.current_question_index not in self.selected_answers: # checks there isnt already a list
                self.selected_answers[self.current_question_index] = [] # assigns empty list
            self.selected_answers[self.current_question_index].append(choice) # adds choice to the answers
        else: # if unselected
            self.selected_answers[self.current_question_index].remove(choice)


    def single_selected(self, choice):
        self.selected_answers[self.current_question_index] = choice
        self.next_question()

    def postcode_selected(self):
        postcode = self.postcode_entry.get().strip()
        if not postcode:
            messagebox.showinfo("Error", "Postcode cannot be blank")
            return
        if not re.match(r'^[A-Z]{1,2}\d[A-Z\d]?\s?\d[A-Z]{2}$', postcode, re.IGNORECASE):
            messagebox.showinfo("Error", "Invalid postcode format")
            return
        self.selected_answers[self.current_question_index] = postcode
        self.next_question()

class mainpage(ctk.CTkFrame):
    def update_saved_universities(self):
        option = self.adduniversitydropdown.get()
        print(option)
    def __init__(self,parent,controller):
        super().__init__(parent)
        self.configure(fg_color="#e8f5e9") # body background
        self.controller = controller
        self.controller.create_header(self) # creates header with search bar

        # saved universities frame
        self.adduniversity_frame = ctk.CTkFrame(self,corner_radius=15, border_width=1,
        fg_color="#e8f5e9",  border_color="#c8e6c9") 
        self.adduniversity_frame.place(relx=0.5, rely=0.28,anchor="center")
        #saved university dropdown table

        self.adduniversitydropdown_label = ctk.CTkLabel(self.adduniversity_frame, 
        text="Add a university", font=("Inter", 50, "bold"), text_color="Black")
        self.adduniversitydropdown_label.pack(pady=20, padx=20)

        # university dropdown

        self.adduniversitydropdown = ctk.CTkOptionMenu(self.adduniversity_frame, height=50, width=300, font=("Tahoma", 20), 
        values=self.controller.universitylist) 
        self.adduniversitydropdown.pack(pady=20,anchor="center")

        # button to add a university
        self.adduniversitybtn = ctk.CTkButton(self.adduniversity_frame, text="Add",font=("Inter",20,"bold"),text_color="white",
        cursor="hand2",fg_color="#25995e",width=300,height=60,corner_radius=12) 
        self.adduniversitybtn.pack(pady=10,padx=0)
        self.adduniversitybtn.bind("<Button-1>", lambda event: self.update_saved_universities()) 
        # FINISHAND DOCUMENT NOT SURE IF WORKS


        """
        
        
       
        self.saveduniversities_frame = ctk.CTkFrame(self, fg_color="white", corner_radius=15, border_width=1, border_color="#c8e6c9") # saved universities frame
        self.saveduniversities_frame.place(relx=0.05, rely=0.15)
        self.saveduniversities_label = ctk.CTkLabel(self.saveduniversities_frame, text="Saved Universities", font=("Tahoma", 30, "bold"), text_color="black", fg_color="white")
        self.saveduniversities_label.pack(pady=20, padx=20)
        """
        # FINISH OFF UNIVERSTY DROPDOWN NEEDS AN ADD BUTTON AND SAVED UNIVERSITIES NEEDS TO BE ABLE TO SAVE UNIVERSITIES

            
                
                



  
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
app = NEA()
app.mainloop()
